<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³é¢‘åŠŸèƒ½å…¨é¢æµ‹è¯•</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 1000px; 
            margin: 0 auto; 
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .test-card {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            margin: 20px 0;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .btn {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            margin: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(0,0,0,0.3); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .status { 
            padding: 10px; 
            margin: 10px 0; 
            border-radius: 8px; 
            font-weight: bold;
        }
        .success { background: rgba(76, 175, 80, 0.3); }
        .error { background: rgba(244, 67, 54, 0.3); }
        .info { background: rgba(33, 150, 243, 0.3); }
        .warning { background: rgba(255, 193, 7, 0.3); }
        #log { 
            background: rgba(0,0,0,0.3);
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            height: 300px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.4;
        }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .voice-item {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            font-size: 12px;
        }
        h1, h2 { text-align: center; margin-bottom: 30px; }
        .loading { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <h1>ğŸ”Š éŸ³é¢‘åŠŸèƒ½å…¨é¢è¯Šæ–­å·¥å…·</h1>
    
    <div class="test-card">
        <h2>ğŸ“‹ ç³»ç»Ÿä¿¡æ¯</h2>
        <div id="system-info"></div>
    </div>

    <div class="test-card">
        <h2>ğŸ”§ æµè§ˆå™¨å…¼å®¹æ€§</h2>
        <div id="compatibility"></div>
        <button class="btn" onclick="checkCompatibility()">é‡æ–°æ£€æµ‹</button>
    </div>

    <div class="test-card">
        <h2>ğŸµ å¯ç”¨è¯­éŸ³åˆ—è¡¨</h2>
        <div id="voices-list" class="loading">æ­£åœ¨åŠ è½½è¯­éŸ³...</div>
        <button class="btn" onclick="loadVoices()">åˆ·æ–°è¯­éŸ³åˆ—è¡¨</button>
    </div>

    <div class="test-card">
        <h2>ğŸ§ª éŸ³é¢‘æ’­æ”¾æµ‹è¯•</h2>
        <div class="grid">
            <button class="btn" onclick="testBasicAudio()">åŸºç¡€éŸ³é¢‘æµ‹è¯•</button>
            <button class="btn" onclick="testWordAudio('hello')">æµ‹è¯• "hello"</button>
            <button class="btn" onclick="testWordAudio('met')">æµ‹è¯• "met"</button>
            <button class="btn" onclick="testWordAudio('above')">æµ‹è¯• "above"</button>
            <button class="btn" onclick="testWordAudio('ice cream')">æµ‹è¯• "ice cream"</button>
            <button class="btn" onclick="testWordAudio('finish')">æµ‹è¯• "finish"</button>
        </div>
        <div id="audio-status"></div>
        <button class="btn" style="background: #f44336;" onclick="stopAllAudio()">åœæ­¢æ‰€æœ‰éŸ³é¢‘</button>
    </div>

    <div class="test-card">
        <h2>âš™ï¸ é«˜çº§è®¾ç½®</h2>
        <div style="margin: 15px 0;">
            <label>è¯­éŸ³: 
                <select id="voice-select" style="margin-left: 10px; padding: 5px; border-radius: 5px;">
                    <option>åŠ è½½ä¸­...</option>
                </select>
            </label>
        </div>
        <div style="margin: 15px 0;">
            <label>è¯­é€Ÿ: <input type="range" id="rate" min="0.1" max="2" step="0.1" value="0.6" style="margin: 0 10px;"> <span id="rate-display">0.6</span></label>
        </div>
        <div style="margin: 15px 0;">
            <label>éŸ³é‡: <input type="range" id="volume" min="0" max="1" step="0.1" value="1" style="margin: 0 10px;"> <span id="volume-display">1.0</span></label>
        </div>
        <div style="margin: 15px 0;">
            <label>éŸ³è°ƒ: <input type="range" id="pitch" min="0.5" max="2" step="0.1" value="1" style="margin: 0 10px;"> <span id="pitch-display">1.0</span></label>
        </div>
        <button class="btn" onclick="testCustomSettings()">ç”¨è‡ªå®šä¹‰è®¾ç½®æµ‹è¯•</button>
    </div>

    <div class="test-card">
        <h2>ğŸ“Š è¯¦ç»†æ—¥å¿—</h2>
        <div id="log"></div>
        <button class="btn" onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
        <button class="btn" onclick="downloadLog()">ä¸‹è½½æ—¥å¿—</button>
    </div>

    <script>
        let allVoices = [];
        let testResults = {};

        // æ—¥å¿—ç³»ç»Ÿ
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const typeEmoji = {
                'success': 'âœ…',
                'error': 'âŒ',
                'warning': 'âš ï¸',
                'info': 'â„¹ï¸'
            };
            
            const logEntry = `${typeEmoji[type] || 'â„¹ï¸'} [${timestamp}] ${message}\n`;
            logDiv.innerHTML += logEntry;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}]`, message);
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        function downloadLog() {
            const logContent = document.getElementById('log').textContent;
            const blob = new Blob([logContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `audio-test-log-${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ç³»ç»Ÿä¿¡æ¯
        function displaySystemInfo() {
            const info = {
                'ç”¨æˆ·ä»£ç†': navigator.userAgent,
                'è¯­è¨€': navigator.language,
                'å¹³å°': navigator.platform,
                'åœ¨çº¿çŠ¶æ€': navigator.onLine ? 'åœ¨çº¿' : 'ç¦»çº¿',
                'æ—¶é—´': new Date().toString()
            };

            let html = '';
            for (const [key, value] of Object.entries(info)) {
                html += `<div><strong>${key}:</strong> ${value}</div>`;
            }
            document.getElementById('system-info').innerHTML = html;
        }

        // å…¼å®¹æ€§æ£€æŸ¥
        function checkCompatibility() {
            const results = [];
            
            if ('speechSynthesis' in window) {
                results.push({ text: 'speechSynthesis API', status: 'success' });
                log('speechSynthesis API æ”¯æŒæ­£å¸¸', 'success');
            } else {
                results.push({ text: 'speechSynthesis API', status: 'error' });
                log('speechSynthesis API ä¸æ”¯æŒ', 'error');
            }

            if ('SpeechSynthesisUtterance' in window) {
                results.push({ text: 'SpeechSynthesisUtterance', status: 'success' });
            } else {
                results.push({ text: 'SpeechSynthesisUtterance', status: 'error' });
            }

            // æ£€æŸ¥HTTPS
            if (location.protocol === 'https:' || location.hostname === 'localhost') {
                results.push({ text: 'HTTPS/Localhost', status: 'success' });
            } else {
                results.push({ text: 'HTTPS/Localhost', status: 'warning' });
                log('å»ºè®®ä½¿ç”¨HTTPSæˆ–localhostä»¥è·å¾—æœ€ä½³å…¼å®¹æ€§', 'warning');
            }

            let html = '';
            results.forEach(result => {
                const emoji = result.status === 'success' ? 'âœ…' : result.status === 'error' ? 'âŒ' : 'âš ï¸';
                html += `<div class="status ${result.status}">${emoji} ${result.text}</div>`;
            });

            document.getElementById('compatibility').innerHTML = html;
        }

        // è¯­éŸ³åŠ è½½
        function loadVoices() {
            return new Promise((resolve) => {
                const voices = speechSynthesis.getVoices();
                if (voices.length > 0) {
                    allVoices = voices;
                    displayVoices();
                    resolve(voices);
                    return;
                }

                const onVoicesChanged = () => {
                    const newVoices = speechSynthesis.getVoices();
                    if (newVoices.length > 0) {
                        allVoices = newVoices;
                        displayVoices();
                        speechSynthesis.removeEventListener('voiceschanged', onVoicesChanged);
                        resolve(newVoices);
                    }
                };

                speechSynthesis.addEventListener('voiceschanged', onVoicesChanged);
                
                // è¶…æ—¶å¤„ç†
                setTimeout(() => {
                    speechSynthesis.removeEventListener('voiceschanged', onVoicesChanged);
                    allVoices = speechSynthesis.getVoices();
                    displayVoices();
                    resolve(allVoices);
                }, 5000);
            });
        }

        function displayVoices() {
            const voicesDiv = document.getElementById('voices-list');
            const voiceSelect = document.getElementById('voice-select');
            
            if (allVoices.length === 0) {
                voicesDiv.innerHTML = '<div class="status error">âŒ æœªæ‰¾åˆ°å¯ç”¨è¯­éŸ³</div>';
                voiceSelect.innerHTML = '<option>æ— å¯ç”¨è¯­éŸ³</option>';
                log('æœªæ‰¾åˆ°ä»»ä½•å¯ç”¨è¯­éŸ³', 'error');
                return;
            }

            log(`æ‰¾åˆ° ${allVoices.length} ä¸ªå¯ç”¨è¯­éŸ³`, 'success');

            // æ˜¾ç¤ºè¯­éŸ³åˆ—è¡¨
            const englishVoices = allVoices.filter(v => v.lang.startsWith('en'));
            const otherVoices = allVoices.filter(v => !v.lang.startsWith('en'));

            let html = `<div class="status success">âœ… æ‰¾åˆ° ${allVoices.length} ä¸ªè¯­éŸ³ (${englishVoices.length} ä¸ªè‹±è¯­è¯­éŸ³)</div>`;
            
            if (englishVoices.length > 0) {
                html += '<h3>ğŸ‡ºğŸ‡¸ è‹±è¯­è¯­éŸ³</h3><div class="grid">';
                englishVoices.forEach(voice => {
                    const defaultBadge = voice.default ? ' ğŸŒŸ' : '';
                    html += `<div class="voice-item">
                        <strong>${voice.name}${defaultBadge}</strong><br>
                        <small>è¯­è¨€: ${voice.lang}<br>
                        æœ¬åœ°: ${voice.localService ? 'æ˜¯' : 'å¦'}<br>
                        URI: ${voice.voiceURI}</small>
                        <button class="btn" style="font-size: 12px; margin-top: 5px;" onclick="testVoice('${voice.name}', '${voice.lang}')">æµ‹è¯•</button>
                    </div>`;
                });
                html += '</div>';
            }

            voicesDiv.innerHTML = html;

            // æ›´æ–°é€‰æ‹©å™¨
            voiceSelect.innerHTML = '<option value="">è‡ªåŠ¨é€‰æ‹©</option>';
            englishVoices.forEach(voice => {
                voiceSelect.innerHTML += `<option value="${voice.name}">${voice.name} (${voice.lang})</option>`;
            });
        }

        // éŸ³é¢‘æµ‹è¯•å‡½æ•°
        async function testBasicAudio() {
            log('å¼€å§‹åŸºç¡€éŸ³é¢‘æµ‹è¯•...', 'info');
            showAudioStatus('æ­£åœ¨æµ‹è¯•åŸºç¡€éŸ³é¢‘æ’­æ”¾...', 'info');

            try {
                const voices = await loadVoices();
                speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance('Testing audio functionality');
                utterance.lang = 'en-US';
                utterance.rate = 0.8;
                utterance.volume = 1.0;

                utterance.onstart = () => {
                    log('åŸºç¡€éŸ³é¢‘æµ‹è¯•: æ’­æ”¾å¼€å§‹', 'success');
                    showAudioStatus('ğŸ”Š éŸ³é¢‘æ­£åœ¨æ’­æ”¾...', 'success');
                };

                utterance.onend = () => {
                    log('åŸºç¡€éŸ³é¢‘æµ‹è¯•: æ’­æ”¾å®Œæˆ', 'success');
                    showAudioStatus('âœ… åŸºç¡€éŸ³é¢‘æµ‹è¯•å®Œæˆ', 'success');
                    testResults.basicAudio = 'success';
                };

                utterance.onerror = (event) => {
                    log(`åŸºç¡€éŸ³é¢‘æµ‹è¯•å¤±è´¥: ${event.error}`, 'error');
                    showAudioStatus(`âŒ éŸ³é¢‘æµ‹è¯•å¤±è´¥: ${event.error}`, 'error');
                    testResults.basicAudio = 'error';
                };

                speechSynthesis.speak(utterance);

                // çŠ¶æ€ç›‘æ§
                setTimeout(() => {
                    log(`æ’­æ”¾çŠ¶æ€: speaking=${speechSynthesis.speaking}, pending=${speechSynthesis.pending}`, 'info');
                }, 500);

            } catch (error) {
                log(`åŸºç¡€éŸ³é¢‘æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                showAudioStatus(`âŒ æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
            }
        }

        async function testWordAudio(word) {
            log(`æµ‹è¯•å•è¯: "${word}"`, 'info');
            showAudioStatus(`æ­£åœ¨æ’­æ”¾å•è¯: "${word}"`, 'info');

            try {
                const voices = await loadVoices();
                speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance(word);
                utterance.lang = 'en-US';
                utterance.rate = parseFloat(document.getElementById('rate').value);
                utterance.volume = parseFloat(document.getElementById('volume').value);
                utterance.pitch = parseFloat(document.getElementById('pitch').value);

                // é€‰æ‹©è¯­éŸ³
                const selectedVoiceName = document.getElementById('voice-select').value;
                if (selectedVoiceName) {
                    const selectedVoice = allVoices.find(v => v.name === selectedVoiceName);
                    if (selectedVoice) {
                        utterance.voice = selectedVoice;
                        log(`ä½¿ç”¨æŒ‡å®šè¯­éŸ³: ${selectedVoice.name}`, 'info');
                    }
                } else {
                    const englishVoice = allVoices.find(v => v.lang.startsWith('en'));
                    if (englishVoice) {
                        utterance.voice = englishVoice;
                        log(`è‡ªåŠ¨é€‰æ‹©è¯­éŸ³: ${englishVoice.name}`, 'info');
                    }
                }

                utterance.onstart = () => {
                    log(`å•è¯ "${word}" å¼€å§‹æ’­æ”¾`, 'success');
                    showAudioStatus(`ğŸ”Š æ­£åœ¨æ’­æ”¾: "${word}"`, 'success');
                };

                utterance.onend = () => {
                    log(`å•è¯ "${word}" æ’­æ”¾å®Œæˆ`, 'success');
                    showAudioStatus(`âœ… "${word}" æ’­æ”¾å®Œæˆ`, 'success');
                    testResults[word] = 'success';
                };

                utterance.onerror = (event) => {
                    log(`å•è¯ "${word}" æ’­æ”¾å¤±è´¥: ${event.error}`, 'error');
                    showAudioStatus(`âŒ "${word}" æ’­æ”¾å¤±è´¥`, 'error');
                    testResults[word] = 'error';
                };

                speechSynthesis.speak(utterance);

            } catch (error) {
                log(`å•è¯ "${word}" æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                showAudioStatus(`âŒ å¼‚å¸¸: ${error.message}`, 'error');
            }
        }

        async function testVoice(voiceName, lang) {
            log(`æµ‹è¯•ç‰¹å®šè¯­éŸ³: ${voiceName} (${lang})`, 'info');
            
            try {
                speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance('Hello, this is a voice test');
                const voice = allVoices.find(v => v.name === voiceName);
                
                if (voice) {
                    utterance.voice = voice;
                    utterance.lang = lang;
                    utterance.rate = 0.8;
                    utterance.volume = 1.0;

                    utterance.onstart = () => log(`è¯­éŸ³ ${voiceName} å¼€å§‹æ’­æ”¾`, 'success');
                    utterance.onend = () => log(`è¯­éŸ³ ${voiceName} æ’­æ”¾å®Œæˆ`, 'success');
                    utterance.onerror = (e) => log(`è¯­éŸ³ ${voiceName} æ’­æ”¾å¤±è´¥: ${e.error}`, 'error');

                    speechSynthesis.speak(utterance);
                }
            } catch (error) {
                log(`æµ‹è¯•è¯­éŸ³ ${voiceName} å¼‚å¸¸: ${error.message}`, 'error');
            }
        }

        function testCustomSettings() {
            const rate = document.getElementById('rate').value;
            const volume = document.getElementById('volume').value;  
            const pitch = document.getElementById('pitch').value;
            
            log(`ä½¿ç”¨è‡ªå®šä¹‰è®¾ç½®æµ‹è¯• - è¯­é€Ÿ:${rate}, éŸ³é‡:${volume}, éŸ³è°ƒ:${pitch}`, 'info');
            testWordAudio('custom settings test');
        }

        function stopAllAudio() {
            speechSynthesis.cancel();
            log('æ‰€æœ‰éŸ³é¢‘å·²åœæ­¢', 'info');
            showAudioStatus('ğŸ›‘ å·²åœæ­¢æ‰€æœ‰éŸ³é¢‘', 'info');
        }

        function showAudioStatus(message, type) {
            const statusDiv = document.getElementById('audio-status');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // æ»‘å—å€¼æ›´æ–°
        document.getElementById('rate').oninput = function() {
            document.getElementById('rate-display').textContent = this.value;
        };
        document.getElementById('volume').oninput = function() {
            document.getElementById('volume-display').textContent = this.value;
        };
        document.getElementById('pitch').oninput = function() {
            document.getElementById('pitch-display').textContent = this.value;
        };

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', function() {
            log('éŸ³é¢‘æµ‹è¯•å·¥å…·åˆå§‹åŒ–', 'info');
            displaySystemInfo();
            checkCompatibility();
            loadVoices();

            // æƒé™æç¤º
            document.addEventListener('click', function() {
                log('æ£€æµ‹åˆ°ç”¨æˆ·äº¤äº’ï¼ŒéŸ³é¢‘åº”è¯¥å¯ä»¥æ­£å¸¸å·¥ä½œ', 'info');
            }, { once: true });
        });

        // å®šæœŸæ£€æŸ¥çŠ¶æ€
        setInterval(() => {
            if (speechSynthesis.speaking) {
                document.title = 'ğŸ”Š éŸ³é¢‘æ’­æ”¾ä¸­...';
            } else {
                document.title = 'ğŸ”Š éŸ³é¢‘åŠŸèƒ½å…¨é¢æµ‹è¯•';
            }
        }, 1000);
    </script>
</body>
</html>